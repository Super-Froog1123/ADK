!pip3 install google-adk==1.1.1
!pip3 install deprecated



import os

# API_KEY = '' # @param {type:"string"}
# os.environ["GOOGLE_GENAI_USE_VERTEXAI"] = "FALSE" # Use Vertex AI API
# os.environ["GOOGLE_API_KEY"] = API_KEY

PROJECT_ID = "colab-20250607"  # @param {type:"string"}
if not PROJECT_ID:
    PROJECT_ID = str(os.environ.get("GOOGLE_CLOUD_PROJECT"))

LOCATION = "us-central1" # @param {type:"string"}

os.environ["GOOGLE_CLOUD_PROJECT"] = PROJECT_ID
os.environ["GOOGLE_CLOUD_LOCATION"] = LOCATION
os.environ["GOOGLE_GENAI_USE_VERTEXAI"] = "TRUE" # Use Vertex AI API
# [your-project-id]

from google.colab import auth
auth.authenticate_user()

import json
import time

def pprint_events(events):
    '''Pretty print of events generated by ADK runner'''
    start_time = time.time()
    for _, event in enumerate(events):
        is_final_response = event.is_final_response()
        function_calls = event.get_function_calls()
        function_responses = event.get_function_responses()
        agent_res = json.loads(event.content.model_dump_json(indent=2, exclude_none=True))

        if is_final_response:
            print('>>> inside final response...')
            final_response = event.content.parts[0].text
            end_time = time.time()
            elapsed_time_ms = round((end_time - start_time) * 1000, 3)
            print(f'Final Response ({elapsed_time_ms} ms):\n{final_response}')
            print("-----------------------------")
        elif function_calls:
            print('+++ inside the function call...')
            for function_call in function_calls:
                print(f"function, [args]:  {function_call.name}, {function_call.args}")
        elif function_responses:
            print('--- inside the function call response...')
            # TODO(Pili): copied from walkthrough codes. Find root cause of 'pending' not found.
            # if not event.actions.pending:
            if True:
                for function_response in function_responses:
                    details = function_response.response
                    recommended_list = list(details.values())
                    print(f"Function Name: {function_response.name}")
                    result=json.dumps(recommended_list)
                    print(f"Function Results {result}")
            else:
                print(agent_res)
    print(f"Total elapsed time: {elapsed_time_ms}")


import warnings
warnings.filterwarnings("ignore", category=UserWarning, module='google.generativeai.types.content_types') # Suppress harmless warning

from google import adk

adk.__version__

from google.adk.agents import Agent
from google.genai import types
from google.adk.tools.agent_tool import AgentTool

MODEL = "gemini-2.0-flash"

from google.adk.agents import Agent, LlmAgent
from google.genai import types
from pydantic import BaseModel
from google.genai import types
from google.adk.sessions import InMemorySessionService
from google.adk.runners import Runner

# Session and Runner
session_service = InMemorySessionService()
session = await session_service.create_session(app_name=APP_NAME, user_id=USER_ID, session_id=SESSION_ID)
runner = Runner(agent=hello_world_agent, app_name=APP_NAME, session_service=session_service)

# Agent Interaction
def call_agent(runner, query):
  content = types.Content(role='user', parts=[types.Part(text=query)])
  events = runner.run(user_id=USER_ID, session_id=SESSION_ID, new_message=content)
  return events

from google.adk.tools import google_search

# Constant
APP_NAME = "hello_search_example"
USER_ID = "user123456"
SESSION_ID = "session123456"
AGENT_NAME = "hello_search_agent"

# Agent
hello_search_agent = Agent(
    model=MODEL,
    name="hello_search_agent",
    description="Agent to answer questions using Google Search.",
    instruction="I can answer your questions by searching the internet. Just ask me anything!",
    generate_content_config=types.GenerateContentConfig(
        max_output_tokens=8000,
    ),
    tools=[google_search],
)

# Session and Runner
session_service = InMemorySessionService()
session = await session_service.create_session(app_name=APP_NAME, user_id=USER_ID, session_id=SESSION_ID)
runner = Runner(agent=hello_search_agent, app_name=APP_NAME, session_service=session_service)

# Agent Interaction
def call_agent(runner, session, query):
  content = types.Content(role='user', parts=[types.Part(text=query)])
  events = runner.run(user_id=session.user_id, session_id=session.id, new_message=content)
  return events

events = call_agent(runner, session, "what is next Google IO date?")
pprint_events(events)

events = call_agent(runner, session, "when is cloud summit Hong Kong?")
pprint_events(events)

import random

async def caller_factory(root_agent, app_name='App12345', user_id='User12345', session_id=None):
  session_service = InMemorySessionService()
  if session_id is None:
    suffix = random.randint(100000, 999999)
    session_id = f'{app_name}-{user_id}-{suffix}'
  session = await session_service.create_session(
      app_name=app_name, user_id=user_id, session_id=session_id)
  runner = Runner(agent=root_agent, app_name=app_name, session_service=session_service)
  def _call(query):
    content = types.Content(role='user', parts=[types.Part(text=query)])
    events = runner.run(user_id=session.user_id, session_id=session.id, new_message=content)
    return events
  return _call

from typing import List
from pydantic import BaseModel, Field
from google.genai import types

json_response_config = types.GenerateContentConfig(
  response_mime_type="application/json",
)

class OutputSchema(BaseModel):
    original_query: str = Field(description="The original text from user.")
    corrected_text: str = Field(description="The corrected text.")
    errors: List[str] = Field(description="An array of descriptions of each error.")
    explanations: List[str] = Field(description="An array of explanations for each correction.")

json_schema = OutputSchema.model_json_schema()
json_schema

# 1. The {json_schema} in instruction is the key for model to follow the schema.
# 2. The output_schema=OutputSchema provides a validation step after model output.

agent_grammar = Agent(
    model=MODEL,
    name='agent_grammar',
    description="This agent corrects grammar mistakes in text provided by children, explains the errors in simple terms, and returns both the corrected text and the explanations.",
    instruction=f"""
        You are a friendly grammar helper for kids.  Analyze the following text,
        correct any grammar mistakes, and explain the errors in a way that a
        child can easily understand.  Don't just list the errors; explain them
        in a paragraph using simple but concise language.

        Output in a JSON object with the below schema:
        {json_schema}
    """,
    output_schema=OutputSchema,
    generate_content_config=json_response_config,
)

call = await caller_factory(root_agent=agent_grammar, app_name='grammar', user_id='User12345', session_id='333')

session_service.sessions.keys()#['grammar']['User12345']['333']

pprint_events(call('ho much is three times 5?'))

pprint_events(call('whut will be 2 plus 3?'))

# session_service.sessions['grammar']['User12345']['333']

# 1. 图表类型分析 Agent
echart_type_agent = Agent(
    model=MODEL,
    name="echart_type_agent",
    description="Determines the appropriate ECharts chart type (e.g., bar, line, pie) based on user intent.",
    instruction="""
        Read the user's request and determine what type of ECharts chart is best suited: bar, line, pie, scatter, word cloud, etc.
        Respond with only the chart type in a single word (e.g., 'bar', 'line').
    """,
    generate_content_config=types.GenerateContentConfig(temperature=0.2),
)

# 2. ECharts 编写 Agent
echart_code_writer_agent = Agent(
    model=MODEL,
    name="echart_code_writer_agent",
    description="Generates ECharts options code based on the chart type and user data.",
    instruction="""
        You are an expert in writing ECharts visualization options.
        Based on the specified chart type and a sample dataset, write the JavaScript code for the ECharts `option` object.
        Respond only with valid ECharts code (JavaScript object), no explanation needed.
    """,
    generate_content_config=types.GenerateContentConfig(temperature=0.2),
)

# 3. Google Sheet 数据接入 Agent（轻量化）
google_sheet_data_agent = Agent(
    model=MODEL,
    name="google_sheet_data_agent",
    description="Helps extract data from a public Google Sheet in CSV format for chart use.",
    instruction="""
        The user will provide a Google Sheet share URL or ID.
        Return a JavaScript fetch() statement that retrieves the CSV version of the sheet and converts it into a data array.
        Don't use external Python libraries.
    """,
    generate_content_config=types.GenerateContentConfig(temperature=0.2),
)

# 主 Agent：协调各子 agent 的任务
echart_master_agent = Agent(
    model=MODEL,
    name="echart_master_agent",
    description="This agent coordinates the process of creating an ECharts visualization based on user needs.",
    instruction="""
        You are a master controller that receives user requests to create ECharts visualizations.
        Step-by-step, decide what type of chart is needed, ask the chart type agent to confirm,
        let the chart writer generate the ECharts code, and finally optionally connect to Google Sheets data if needed.
        Output the final HTML/JS code for embedding.
    """,
    tools=[
        AgentTool(agent=echart_type_agent),
        AgentTool(agent=echart_code_writer_agent),
        AgentTool(agent=google_sheet_data_agent),
    ],
    generate_content_config=types.GenerateContentConfig(temperature=0.3),
)

from google.adk.agents.sequential_agent import SequentialAgent

echart_sequence_agent = SequentialAgent(
    name="echart_sequence_agent",
    description="Sequential agent that analyzes chart type, fetches data, and generates ECharts option code.",
    sub_agents=[echart_type_agent, google_sheet_data_agent, echart_code_writer_agent],
)

call_chart = await caller_factory(root_agent=echart_sequence_agent)

query = "Make a pie chart showing expenses from this sheet: https://docs.google.com/spreadsheets/d/131B6_H1DotaDzpYqV5Z2tgMcpcEPJS_6rX6wrE2CTOg/edit?usp=sharing"

for event in call_chart(query):  # ✅ 普通 for 循环
    if event.content:
        print(event.content.parts[0].text)


agent_grammar = Agent(
    model=MODEL,
    name='agent_grammar',
    description="This agent corrects grammar mistakes in text provided by children, explains the errors in simple terms, and returns both the corrected text and the explanations.",
    instruction=f"""
        You are a friendly grammar helper for kids.  Analyze the following text,
        correct any grammar mistakes, and explain the errors in a way that a
        child can easily understand.  Don't just list the errors; explain them
        in a paragraph using simple but concise language.

        Output in a JSON object with the below schema:
        {json_schema}
    """,
    output_schema=OutputSchema,
    generate_content_config=json_response_config,
)

from google.adk.tools.tool_context import ToolContext

def exit_loop(tool_context: ToolContext):
  tool_context.actions.escalate = True

agent_checker = Agent(
    model=MODEL,
    name="agent_checker",
    description="This agent checks if the kid's query is fulfilled. It escalates if both grammar is fixed and the math is calculated",
    instruction="""
    Analyze the chat log between the user (kids) and other agents.

    We are expecting two outcomes from the conversation.
    1. agent_grammar helps to fix the grammar of kid's question.
    2. agent_math_advanced tries to solve the math step by step.

    Decide the action and respond as follows:

    1. If you find user question is incomplete in the chat log, ask a clarification question to the kid. Then call `exit_loop`.

    2. If both agent_grammar and agent_math_advanced have done their task, summarize the answer in a friendly way to the kid. Then call `exit_loop`.

    3. If there is no pending math problem to solve, friendly tell the kid you help fix grammar and solve math, but does not know anything else. Politely ask for math question. Then call exit_loop.

    4. If agent_grammar has fixed the grammar but agent_math_advanced has not generated a final answer with single number, extract corrected_text from most recent JSON response and empahsize that is the math question to solve.

    5. Otherwise, say "Thanks for the question! I'll let grammar and math agent to help you!". Do not call any tools in this case.

    """,
    tools=[exit_loop]
)

agent_extractor = Agent(
    model=MODEL,
    name="agent_extractor",
    description="Extract corrected_text from most recent JSON response and empahsize that is the math question to solve.",
    instruction="""
    Extract corrected_text from most recent JSON response and empahsize that is the math question to solve.
    """,
    generate_content_config=types.GenerateContentConfig(temperature=0.2),
    input_schema=OutputSchema,
)


echart_type_agent2 = Agent(
    model=MODEL,
    name="echart_type_agent_loop",
    description=echart_type_agent.description,
    instruction=echart_type_agent.instruction,
    generate_content_config=types.GenerateContentConfig(temperature=0.2),
)

google_sheet_data_agent2 = Agent(
    model=MODEL,
    name="google_sheet_data_agent_loop",
    description=google_sheet_data_agent.description,
    instruction=google_sheet_data_agent.instruction,
    generate_content_config=types.GenerateContentConfig(temperature=0.2),
)

echart_code_writer_agent2 = Agent(
    model=MODEL,
    name="echart_code_writer_agent_loop",
    description=echart_code_writer_agent.description,
    instruction=echart_code_writer_agent.instruction,
    generate_content_config=types.GenerateContentConfig(temperature=0.2),
)

from google.adk.agents.loop_agent import LoopAgent

echart_loop_agent = LoopAgent(
    name="echart_loop_agent",
    description="""
        This agent helps users create ECharts visualizations through a loop of sub-agents.
        It will analyze the user's intent, determine chart type, optionally fetch Google Sheet data,
        and finally generate valid ECharts option code.
    """,
    sub_agents=[
        echart_type_agent2,
        google_sheet_data_agent2,
        echart_code_writer_agent2
    ],
)


call = await caller_factory(root_agent=echart_loop_agent)